#!/usr/bin/env python
from __future__ import  with_statement, print_function
import select
import socket
import sys
import argparse
import petname
import logging
import signal
import time
import json
import jsonschema
import IRC
from IRC.Handler import SocketBuffer

class IRCUser(object):
    def __init__(self, socket, address):
        self.__sb = SocketBuffer(socket, misc=self)
        self.__address = address
        self.__name = petname.Generate(2, "")[0:9]
        self.__channels = []
        self.__ping = None
        logging.info('User \'%s\' created.', self)

    def unansweredPing(self):
        return self.__ping != None

    def sendPing(self, server, ping):
       self.__ping = ping
       #logging.info("Sending Ping {ping}".format(ping=ping))
       server.sendMsg(self.__sb, server.getIRCMsg().cmdPing(ping))

    def receivedPong(self, pong):
       if self.__ping == None:
           logging.warning("Received a pong where no ping existed.")
           return False
       elif self.__ping != pong:
           logging.warning("Received incorrect pong '{ping}' != '{pong}' ".format(ping=self.__ping, pong=pong))
           return False
       else:
           self.__ping = None
           return True

    def getChannels(self):
        return self.__channels

    def removeChannel(self, c):
        self.__channels.remove(c)

    def addChannel(self, c):
        self.__channels.append(c)

    def getName(self):
        return self.__name

    def changeName(self, name):
        logging.info("User changed name from {old} to {new}.".format(old=self.__name, new=name))
        self.__name = name

    def leave(self, handler):
        logging.info("User %s left", self)

        for c in self.__channels:
            c.removeUser(self)

        self.__sb.close()

    def getSocketBuffer(self):
        return self.__sb

    def __str__(self):
        return "%s %s" % (self.__name, self.__address)

class IRCChannel:
    def __init__(self, name):
        self.__name = name
        self.__users = []

    def addUser(self, user):
        self.__users.append(user)
        user.addChannel(self)

    def removeUser(self, user):
        self.__users.remove(user)
        user.removeChannel(self)

    def userInChannel(self, user):
        return user in self.__users

    def __str__(self):
        return "%s" % (self.__name)

    def getName(self):
        return str(self)

    def getUsers(self):
        return self.__users

def chunks(l, n):
    """Yield successive n-sized chunks from l."""
    for i in xrange(0, len(l), n):
        yield l[i:i+n]

SERVERNAME = "SERVER"
NEWUSERNAME = "NEWUSER"
SPECIALNAMES = [SERVERNAME, NEWUSERNAME]

class IRCServer(IRC.Handler.IRCHandler):
    def __init__(self, host, port):
        super(IRCServer, self).__init__(SERVERNAME)
        backlog = 5
        logging.basicConfig(stream=sys.stdout, level=logging.DEBUG)
        self.__size = 1024
        self.__server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.__server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.__server.bind((host,port))
        self.__server.listen(backlog)
        self.__server = SocketBuffer(self.__server, misc=None)
        self.__rooms = []
        self.__users = []
        self.__running = False
        self.__last_ping = 0

    def findCreateChannel(self, roomName):
        channel = self.findChannelByName(roomName)
        if channel != None:
            return channel
        else:
            logging.info('Creating room \'%s\'.', roomName)
            newRoom = IRCChannel(roomName)
            self.__rooms.append(newRoom)
            return newRoom

    def newUser(self, client, address):
        user = IRCUser(client, address)
        userIRC = IRC.Message.IRCMessage(NEWUSERNAME)
        self.sendMsg(user.getSocketBuffer(), userIRC.cmdNick(user.getName()))
        self.__users.append(user)

    def endUser(self, user, msg):
        userIRC = IRC.Message.IRCMessage(user.getName())
        if user in self.__users:
            self.sendMsg(user.getSocketBuffer(), userIRC.cmdQuit(msg))

            channels = list(user.getChannels())
            user.leave(self)
            self.__users.remove(user)

            for c in channels:
                self.sendMsgToSockets(map(lambda u: u.getSocketBuffer(), c.getUsers()), userIRC.cmdQuit(msg))


    def timeStep(self):
        if time.time() - self.__last_ping > 2:
            #logging.info("Verifying Pongs/Sending Pings")
            for client in self.__users:
                if client.unansweredPing():
                      self.endUser(client, 'No ping response')
                else:
                      client.sendPing(self, str(time.time()))

            self.__last_ping = time.time()

    def findUserByName(self, name):
        results = filter(lambda x : x.getName() == name, self.__users)
        if len(results) == 0:
            return None
        else:
            return results[0]

    def findChannelByName(self, name):
        results = filter(lambda x : x.getName() == name, self.__rooms)
        if len(results) == 0:
            return None
        else:
            return results[0]

    def userNameAvailable(self, name):
        return all(map(lambda n : n != name, map(lambda x: x.getName(), self.__users) + SPECIALNAMES))

    def connectionDrop(self, socket):
        user = socket.getMisc()
        logging.info("{user} disconnected.".format(user=user.getName()))
        self.endUser(user, 'Connection Drop')

    def getInputSocketList(self):
        inputs = [self.__server]
        inputs.extend(map(lambda u : u.getSocketBuffer(), self.__users))
        return inputs

    def getOutputSocketList(self):
        return filter(lambda s: s.readyToSend(), map(lambda u : u.getSocketBuffer(), self.__users))

    def socketInputReady(self, socket):
        if socket == self.__server:
            client, address = self.__server.accept()
            self.newUser(client, address)
        elif type(socket) is SocketBuffer and type(socket.getMisc()) is IRCUser:
            self.receiveMsg(socket)
        else:
            logging.critical("Unknown socket connection %s %s " % (socket, type(socket)))

    def socketExceptReady(self, socket):
        pass # not sure if needs handling

    def validTargets(self, targets):
        return all(
            map(lambda t : self.findChannelByName(t) != None or self.findUserByName(t) != None,
            targets))

    def socketTargets(self, targets):
        socket_targets = []
        for t in targets:
            channel = self.findChannelByName(t)
            user = self.findUserByName(t)
            if channel != None:
                socket_targets.extend(map(lambda x: x.getSocketBuffer(), channel.getUsers()))
            elif user != None:
                socket_targets.append(user.getSocketBuffer())

        return socket_targets

    def sendMsgToTargets(self, targets, msg):
        if not self.validTargets(targets):
            return

        sockets = self.socketTargets(targets)
        self.sendMsgToSockets(sockets, msg)

    def sendMsgToSockets(self, sockets, msg):
        for s in sockets:
            super(IRCServer, self).sendMsg(s, msg)

    def receivedNick(self, socket, src, newnick):
        if self.userNameAvailable(newnick):
            user = socket.getMisc()
            userIRC = IRC.Message.IRCMessage(user.getName())
            user.changeName(newnick)
            self.sendMsg(socket, userIRC.cmdNick(newnick))
            for c in user.getChannels():
                self.sendMsgToSockets(map(lambda u: u.getSocketBuffer(), c.getUsers()), userIRC.cmdNick(newnick))
        else:
            self.sendMsg(socket,
                         self._ircmsg.errorMsg("badnick",
                                               "{newnick} already in use.".format(newnick=newnick)
                         )
            )

    def receivedQuit(self, socket, src, msg):
        self.endUser(socket.getMisc(), msg)

    def receivedSQuit(self, socket, msg):
        pass # server should not receive SQUIT messages

    def receivedJoin(self, socket, src, channels):
        user = socket.getMisc()
        exist_channels = filter(lambda c : c != None, map(lambda c: self.findChannelByName(c), channels))

        if any(map(lambda c: c.userInChannel(user), exist_channels)):
            self.sendMsg(socket, self._ircmsg.errorMsg("member", "Already a member of one or more channels"))
        else:
            userIRC = IRC.Message.IRCMessage(user.getName())
            match_channels = map(lambda c: self.findCreateChannel(c), channels)
            for c in match_channels:
                c.addUser(user)
                self.sendMsgToSockets(map(lambda u: u.getSocketBuffer(), c.getUsers()), userIRC.cmdJoin([c.getName()]))
                for chunk in chunks(c.getUsers(), 5):
                    self.sendMsg(socket, self._ircmsg.replyNames(c.getName(), map(lambda u : u.getName(), chunk)))
                self.sendMsg(socket,self._ircmsg.replyNames(c.getName(), []))

    def receivedLeave(self, socket, src, channels, msg):
        user = socket.getMisc()
        match_channels = map(lambda c: self.findChannelByName(c), channels)

        if not all(map(lambda c: c != None, match_channels)):
            self.sendMsg(socket, self._ircmsg.errorMsg("nochannel", "One or more channels does not exist"))
        elif not all(map(lambda c: c.userInChannel(user), match_channels)):
            self.sendMsg(socket, self._ircmsg.errorMsg("nonmember", "Not a member in one or more channels"))
        else:
            userIRC = IRC.Message.IRCMessage(user.getName())
            for c in match_channels:
                self.sendMsgToSockets(map(lambda u: u.getSocketBuffer(), c.getUsers()), userIRC.cmdLeave([c.getName()], msg))
                c.removeUser(user)

    def receivedChannels(self, socket):
        for c in chunks(map(lambda x : x.getName(), self.__rooms), 5):
            self.sendMsg(socket, self._ircmsg.replyNames('#fake', c))
        self.sendMsg(socket, self._ircmsg.replyNames('#fake', []))

    def receivedUsers(self, socket, channels):
        for c in channels:
            chan = self.findChannelByName(c)
            if chan:
                for u in chunks(map(lambda x : x.getName(), chan.getUsers()), 5):
                    self.sendMsg(socket, self._ircmsg.replyNames(c, u))
                self.sendMsg(socket, self._ircmsg.replyNames(c, []))
            else:
                self.sendMsg(socket, self._ircmsg.errorMsg("nochannel", "One or more channels does not exist"))

    def receivedPing(self, socket, msg):
        pass #should not receive pings from users

    def receivedPong(self, socket, msg):
        user = socket.getMisc()
        if not user.receivedPong(msg):
            self.endUser(user, 'Unexpected Pong')

    def receivedInvalid(self, socket, msg):
        try:
            jmsg = json.loads(msg)
            jsonschema.validate(jmsg, IRC.Schema.Defn)
        except ValueError as e:
            logging.info(str(e))
        except jsonschema.exceptions.ValidationError as e:
            logging.info("Schema Message {msg}".format(msg=e.message))
        else:
            logging.error("Schema message passed validation but failed? {msg}".format(msg=msg))
            raise BaseException("Improperly handled Validation")

        self.sendMsg(socket, self._ircmsg.errorMsg("schema", "Invalid Schema in Request"))

    def receivedSignal(self, signal, frame):
        logging.warning("Server interrupted with Ctrl-C.")
        self.stop()

    def receivedError(self, socket, etype, emsg):
        pass #Server doesn't care.

    def receivedMsg(self, socket, src, targets, msg):
        srcUser = socket.getMisc()
        userIRC = IRC.Message.IRCMessage(srcUser.getName())

        msg = userIRC.cmdMsg(msg, targets)

        if not self.validTargets(targets):
            self.sendMsg(socket, self._ircmsg.errorMsg("nonexist", "One or more channels/users does not exist"))
        else:
            self.sendMsgToTargets(targets, msg)

    def receivedNames(self, socket, names):
        pass # server should not received messages

    def receivedOk(self, socket):
        pass # server should not receive ok

    def sentInvalid(self, socket, msg):
        logging.error("Attempted to send invalid message {msg} to {user}".format(
            msg=msg, user=socket.getMisc().getName()))

    def shutdown(self):
        logging.info("Shutting down server.")
        self.__running = False
        self.__server.close()
        for u in self.__users:
            self.endUser(u, 'Server Shutdown')
        logging.info("Server shut down.")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="IRC Server")
    parser.add_argument('--hostname', help="Hostname", default="localhost")
    parser.add_argument('--port', type=int, help="Port", default=50000)
    parser.add_argument('--log', default=None)

    args = parser.parse_args()

    if args.log != None:
        logging.basicConfig(filename=args.log, filemode='w', level=logging.DEBUG)

    server = IRCServer(args.hostname, args.port)
    server.run()
