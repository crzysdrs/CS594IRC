#!/usr/bin/env python
import socket
import sys
import IRC
import argparse
import re
import select
import json
from  more_itertools import unique_everseen
from collections import deque

class CommandParseError(Exception):
    def __init__(self, msg):
        self.__msg = msg

    def __str__(self):
        return self.__msg

class CommandParseUnimplemented(CommandParseError):
    def __init__(self, msg):
        self.__msg = msg
    def __str__(self):
        return "Unimplemented: %s" % (self.__msg)
    
class CmdArg:
    def __init__(self, regex, error):
        self.__regex = regex
        self.__error = error

    def pattern(self):
        return self.__regex

    def error(self):
        return self.__error
    
def unhandledCmd(c, *args, **kwargs):
    raise CommandParseUnimplemented(c.name())
    
class Command:
    def __init__(self, name, cmd=unhandledCmd, args=None, extra=False):
        self.__name = name
        if args:
            self.__args = args
        else:
            self.__args = []
        self.__cmd = cmd
        self.__extra = extra
        
    def name(self):
        return self.__name

    def __pattern(self):
        p = "^/" + self.__name
        for a in self.__args:
            p += '\s+(\S+)'
        p += '\s*'
        if self.__extra:
            p += '(.*)'
        p += '\r?\n$'
        return p
    
    def verify(self, line):        
        m = re.match(self.__pattern(), line)
        if m:
            compare = map (lambda (arg, s): (arg, re.match(arg.pattern(), s), s),  zip(self.__args, m.groups()))
            valid = True
            for (a, v, s) in compare:
                if not v:
                    raise CommandParseError("Invalid Argument: %s, Error: %s" % (s, a.error()))
                    valid = False

            return valid
        else:
            raise CommandParseError("Expected %d argument(s)" % (len(self.__args)))
            return False

    def execute(self, irc, line):
        if not self.verify(line):
            return    
        m = re.match(self.__pattern(), line)
        return self.__cmd(self, irc, *m.groups())

def processCmd(irc, line):
    currentChannel = "#lobby"
    if not isCmd(line):
        return irc.cmdMsg(line.rstrip(), [currentChannel])

    matched_cmd = filter(lambda c: re.match(r'^/{name}\b'.format(name=c.name()), line), COMMANDS)
    
    if len(matched_cmd) == 0:
        raise CommandParseError("Unknown command %s" % re.match("^(/\S+)", line).group(1))
    elif len(matched_cmd) > 1:
        raise BaseException("Multiple command matches")
    
    cmd = matched_cmd[0]
    return cmd.execute(irc, line)

def unique(items):
    return list(unique_everseen(items))
    
def joinCmd(c, irc, channels):
    return irc.cmdJoin(unique(channels.split(',')))

def leaveCmd(c, irc, channels, msg):
    return irc.cmdLeave(unique(channels.split(',')), msg)

def channelsCmd(c, irc):
    return irc.cmdChannels()

def usersCmd(c, irc, channels):
    return irc.cmdUsers(unique(channels.split(',')))

def nickCmd(c, irc, nick):
    return irc.cmdNick(nick)

def quitCmd(c, irc, msg):
    return irc.cmdQuit(msg)

def msgCmd(c, irc, nicks, msg):
    return irc.cmdMsg(msg, unique(nicks.split(',')))

CHANNEL_LIST = "^({channel},)*{channel}$".format(channel=IRC.IRCChannel)
NICK_LIST = "^({nick},)*{nick}$".format(nick=IRC.IRCNick)
COMMANDS = [
    Command('join',
            cmd=joinCmd,
            args=[
                CmdArg(CHANNEL_LIST, "Invalid Channel List")
            ]
    ),
    Command('leave',
            cmd=leaveCmd,
            args=[            
                CmdArg(CHANNEL_LIST, "Invalid Channel List")
            ],
            extra=True
    ),
    Command('channels',
            cmd=channelsCmd
    ),
    Command('users',
            cmd=usersCmd,
            args=[
                CmdArg(CHANNEL_LIST, "Invalid Channel List")
            ]
    ),
    Command('nick',
            cmd=nickCmd,
            args=[
                CmdArg('^{nick}$'.format(nick=IRC.IRCNick), "Invalid NickName")
            ]
    ),
    Command('quit',
            cmd=quitCmd,
            extra=True
    ),
    Command('msg',
            cmd=msgCmd,
            args=[
                CmdArg(NICK_LIST, "Invalid Nickname List")
            ],
            extra=True
    )
]

def isCmd(line):
    if len(line) > 0:
        return line[0] == '/'
    else:
        return False

def clientIgnore(some_func):
    def inner():
        print "Client received an ignored message."
        return
    return inner

class IRCClient(IRC.IRCHandler):
    def __init__(self, hostname, port ):
        super(IRCClient, self).__init__("client")
        self.__server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.__server.connect((hostname, port))
        self.__currentChannel = "#lobby"
        self.__nick = "name"
        self.__msgQueue = deque([])
        
    def getSocketList(self):
        return [sys.stdin, self.__server]

    def socketInputReady(self, socket):
        if socket == sys.stdin:
            stdin = socket
            try:
                msg = stdin.readline()
                send = processCmd(self._ircmsg, msg)
                self.sendMsg(self.__server, send)
            except CommandParseError as e:
                print "Error Encountered Parsing Command: %s" % (e)
        else:
            self.receiveMsg(socket)

    def sendMsg(self, socket, send):
        super(IRCClient, self).sendMsg(socket, send)
        #Invalid messages will not be in message queue
        self.__msgQueue.append(send)
        
    def socketExceptReady(self, socket):
        pass #does the client care?
    
    def connectionDrop(self, socket):
        pass

    @clientIgnore
    def receivedNick(self, socket, newnick):
        pass

    @clientIgnore
    def receivedQuit(self, socket, msg):
        pass

    def receivedSQuit(self, socket, msg):
        pass

    @clientIgnore
    def receivedJoin(self, socket, channels):
        pass

    @clientIgnore
    def receivedLeave(self, socket, channels, msg):
        pass

    @clientIgnore
    def receivedChannels(self, socket):
        pass

    @clientIgnore
    def receivedUsers(self, socket, channels):
        pass

    def receivedMsg(self, socket, src, targets, msg):
        if self.__nick in targets:
            print "*** {src}: {msg}".format(src=src, msg=msg)
        elif self.__currentChannel in targets:
            print "{src}: {msg}".format(src=src, msg=msg)

    def receivedPing(self, socket, msg):
        self.sendMsg(socket, self._ircmsg.cmdPong(msg))

    @clientIgnore
    def receivedPong(self, socket, msg):
        pass

    def receivedOk(self, socket):
        #remove ok'd messages from queue
        top = self.__msgQueue.popleft()

        if 'cmd' in top:
            if top['cmd'] == 'nick':
                self.__nick = top['update']
            elif top['cmd'] == 'join':
                self.channels = unique(self.__channels.extend(top['channels']))
            elif top['cmd'] == 'leave':
                self.channels.remove(top['channels'])

    def receivedNames(self, socket, names):
        if len(names) == 0:
            #last message in response means we can take the message off the top
            self.__msgQueue.popleft()
        else:
            top = self.__msgQueue[0]
            if 'cmd' in top and top['cmd'] in ['users', 'join']:                
                print "{info} : {names} ".format(info=top['channels'], names=" ".join(names))
            elif 'cmd' in top and top['cmd'] in ['channels']:
                print "channels : {names} ".format(names=" ".join(names))
            else:
                print "(unknown) {names}".format(names=" ".join(names))
                
    def receivedError(self, socket, error_name, error_msg):
        print "ERROR: {error_t}: {error_m}".format(error_t=error_name, error_m=error_msg)
        self.__msgQueue.popleft()
        
    def receivedInvalid(self, socket, msg):
        print "BAD SERVER MSG: {msg}".format(msg=msg)
        self.__msgQueue.popleft()

    def receivedSignal(self, signal, frame):
        print("Client interrupted with Ctrl-C.")
        self.stop()

    def sentInvalid(self, socket, msg):
        print "CLIENT ERROR: {msg}".format(msg=msg)        

    def shutdown(self):
        print "*** Shutting Down Client ***"
        self.__server.shutdown(socket.SHUT_RDWR)
        self.__server.close()
                
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="IRC Client")
    parser.add_argument('--hostname', help="Hostname", default="localhost")
    parser.add_argument('--port', type=int, help="Port", default=50000)
    
    args = parser.parse_args()

    client = IRCClient(args.hostname, args.port)
    client.run()
    

